// Import dependencies
import dotenv from 'dotenv';
import Fastify from 'fastify';
import fastifyCookie from '@fastify/cookie';
import fastifySession from '@fastify/session';
import fastifyWs from '@fastify/websocket';
import fastifyFormbody from '@fastify/formbody';
import fastifyView from '@fastify/view';
import { MongoClient } from 'mongodb';
import twilio from 'twilio';
import ejs from 'ejs';
import bcrypt from 'bcrypt';
import path from 'path';
import { fileURLToPath } from 'url';
import crypto from 'crypto';
import WebSocket from 'ws';
import Stripe from 'stripe';

// Load environment variables
dotenv.config();

// Get environment variables
const { 
    MONGODB_URI, 
    TWILIO_ACCOUNT_SID, 
    TWILIO_AUTH_TOKEN, 
    TWILIO_VERIFY_SERVICE_SID,
    OPENAI_API_KEY,
    STRIPE_SECRET_KEY,
    STRIPE_PUBLISHABLE_KEY,
    SESSION_SECRET
} = process.env;

// Validate required environment variables
if (!MONGODB_URI || !TWILIO_ACCOUNT_SID || !TWILIO_AUTH_TOKEN || !TWILIO_VERIFY_SERVICE_SID || 
    !OPENAI_API_KEY || !STRIPE_SECRET_KEY || !STRIPE_PUBLISHABLE_KEY || !SESSION_SECRET) {
    console.error('Missing required environment variables. Please check your .env file.');
    process.exit(1);
}

// Initialize Stripe
const stripe = new Stripe(STRIPE_SECRET_KEY);

// Define product IDs (you'll need to create these in Stripe dashboard)
const STRIPE_PRODUCTS = {
    '1_HOUR': 'price_1_hour_id',
    '3_HOURS': 'price_3_hours_id',
    '5_HOURS': 'price_5_hours_id'
};

// Get current directory for ES modules
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Create Fastify instance
const fastify = Fastify({
    logger: true
});

// Register plugins
await fastify.register(fastifyCookie);
await fastify.register(fastifySession, {
    secret: SESSION_SECRET,
    cookie: {
        secure: process.env.NODE_ENV === 'production'
    }
});
await fastify.register(fastifyFormbody);
await fastify.register(fastifyWs);

// Register view engine
await fastify.register(fastifyView, {
    engine: {
        ejs: ejs
    },
    root: path.join(__dirname, 'views'),
    layout: '/layouts/main.ejs',
    propertyName: 'view'
});

// Initialize MongoDB
let db;
const connectDB = async () => {
    try {
        const client = await MongoClient.connect(MONGODB_URI);
        db = client.db('voice-ai');
        console.log('Connected to MongoDB');
    } catch (err) {
        console.error('MongoDB connection error:', err);
        process.exit(1);
    }
};

// Initialize Twilio client
const twilioClient = twilio(TWILIO_ACCOUNT_SID, TWILIO_AUTH_TOKEN);

// Register routes
fastify.register(async function (fastify) {
    // Pricing and Payment Routes
    fastify.get('/pricing', async (request, reply) => {
        const user = request.session.user;
        return reply.view('pricing.ejs', { 
            title: 'Pricing',
            user: user || null,
            stripePublishableKey: STRIPE_PUBLISHABLE_KEY,
            redirectUrl: user ? null : '/login?redirect=/pricing'
        });
    });

    fastify.post('/create-checkout-session', {
        preHandler: fastify.authenticate
    }, async (request, reply) => {
        const { priceId } = request.body;
        
        try {
            const session = await stripe.checkout.sessions.create({
                payment_method_types: ['card'],
                line_items: [{
                    price: priceId,
                    quantity: 1,
                }],
                mode: 'payment',
                success_url: `${request.protocol}://${request.hostname}/payment-success?session_id={CHECKOUT_SESSION_ID}`,
                cancel_url: `${request.protocol}://${request.hostname}/pricing`,
                customer_email: request.session.user.email,
                metadata: {
                    userId: request.session.user.email
                }
            });

            return reply.send({ sessionId: session.id });
        } catch (error) {
            console.error('Stripe session creation error:', error);
            return reply.status(500).send({ error: 'Failed to create checkout session' });
        }
    });

    fastify.get('/payment-success', {
        preHandler: fastify.authenticate
    }, async (request, reply) => {
        const sessionId = request.query.session_id;
        
        try {
            const session = await stripe.checkout.sessions.retrieve(sessionId);
            const minutes = getMinutesFromPriceId(session.line_items.data[0].price.id);
            
            // Update user's available minutes
            await db.collection('users').updateOne(
                { email: request.session.user.email },
                { 
                    $inc: { availableMinutes: minutes },
                    $push: {
                        purchases: {
                            date: new Date(),
                            minutes: minutes,
                            amount: session.amount_total / 100,
                            sessionId: sessionId
                        }
                    }
                }
            );

            return reply.redirect('/dashboard?payment=success');
        } catch (error) {
            console.error('Payment processing error:', error);
            return reply.redirect('/dashboard?payment=error');
        }
    });

    // Helper function to get minutes from price ID
    function getMinutesFromPriceId(priceId) {
        switch(priceId) {
            case STRIPE_PRODUCTS['1_HOUR']:
                return 60;
            case STRIPE_PRODUCTS['3_HOURS']:
                return 180;
            case STRIPE_PRODUCTS['5_HOURS']:
                return 300;
            default:
                return 0;
        }
    }

    // Dashboard Routes
    fastify.get('/dashboard', {
        preHandler: fastify.authenticate
    }, async (request, reply) => {
        try {
            const user = await db.collection('users').findOne({ email: request.session.user.email }) || 
                        await db.collection('pending_users').findOne({ email: request.session.user.email });
            
            if (!user) {
                return reply.redirect('/login');
            }

            // Calculate total minutes used from call history
            const calls = await db.collection('calls').find({ userId: user.email }).toArray();
            const minutesUsed = calls.reduce((total, call) => {
                if (call.endTime) {
                    const duration = (new Date(call.endTime) - new Date(call.startTime)) / 1000 / 60;
                    return total + duration;
                }
                return total;
            }, 0);

            const availableMinutes = (user.availableMinutes || 0) - minutesUsed;
            
            return reply.view('dashboard.ejs', { 
                title: 'Dashboard',
                user: user,
                calls: calls,
                availableMinutes: Math.max(0, availableMinutes),
                minutesUsed: minutesUsed,
                paymentStatus: request.query.payment
            });
        } catch (error) {
            console.error('Dashboard error:', error);
            return reply.status(500).send({ error: 'Internal server error' });
        }
    });

    fastify.get('/call-history', {
        preHandler: fastify.authenticate
    }, async (request, reply) => {
        try {
            const calls = await db.collection('calls')
                .find({ userId: request.session.user.email })
                .sort({ startTime: -1 })
                .toArray();

            const user = await db.collection('users').findOne({ email: request.session.user.email });
            
            // Calculate minutes for each call and total
            const callsWithDuration = calls.map(call => ({
                ...call,
                duration: call.endTime ? Math.round((new Date(call.endTime) - new Date(call.startTime)) / 1000 / 60) : 0
            }));

            const totalMinutesUsed = callsWithDuration.reduce((total, call) => total + call.duration, 0);
            const availableMinutes = (user.availableMinutes || 0) - totalMinutesUsed;

            return reply.view('call-history.ejs', {
                title: 'Call History',
                user,
                calls: callsWithDuration,
                totalMinutesUsed,
                availableMinutes: Math.max(0, Math.round(availableMinutes))
            });
        } catch (error) {
            console.error('Call history error:', error);
            return reply.redirect('/dashboard');
        }
    });

    // WebSocket Route
    fastify.get('/call-stream', { websocket: true }, (connection, request) => {
        connection.socket.on('message', async (message) => {
            try {
                const user = await db.collection('users').findOne({ email: request.session.user.email });
                const calls = await db.collection('calls').find({ userId: user.email }).toArray();
                const minutesUsed = calls.reduce((total, call) => {
                    if (call.endTime) {
                        const duration = (new Date(call.endTime) - new Date(call.startTime)) / 1000 / 60;
                        return total + duration;
                    }
                    return total;
                }, 0);

                const availableMinutes = (user.availableMinutes || 0) - minutesUsed;

                if (availableMinutes <= 0) {
                    connection.socket.send(JSON.stringify({
                        type: 'error',
                        message: 'No minutes remaining. Please purchase more time to continue.'
                    }));
                    connection.socket.close();
                    return;
                }

                // Continue with existing WebSocket logic
                let streamSid = null;
                let callRecord = null;
                let latestMediaTimestamp = 0;
                let lastAssistantItem = null;
                let markQueue = [];
                let responseStartTimestampTwilio = null;

                // Connect to OpenAI Realtime API
                const openAiWs = new WebSocket('wss://api.openai.com/v1/realtime?model=gpt-4o-realtime-preview-2024-10-01', {
                    headers: {
                        Authorization: `Bearer ${OPENAI_API_KEY}`,
                        "OpenAI-Beta": "realtime=v1"
                    }
                });

                // Initialize OpenAI session
                const initializeSession = () => {
                    const sessionUpdate = {
                        type: 'session.update',
                        session: {
                            turn_detection: { type: 'server_vad' },
                            input_audio_format: 'g711_ulaw',
                            output_audio_format: 'g711_ulaw',
                            voice: 'alloy',
                            instructions: 'You are a helpful and bubbly AI assistant who loves to chat about anything the user is interested about and is prepared to offer them facts. Always stay positive, but work in a joke when appropriate and be as engaging as possible.',
                            modalities: ["text", "audio"],
                            temperature: 0.8,
                        }
                    };
                    console.log('Sending session update:', JSON.stringify(sessionUpdate));
                    openAiWs.send(JSON.stringify(sessionUpdate));

                    // Have AI speak first
                    sendInitialConversationItem();
                };

                // Send initial conversation item for AI to speak first
                const sendInitialConversationItem = () => {
                    const initialConversationItem = {
                        type: 'conversation.item.create',
                        item: {
                            type: 'message',
                            role: 'user',
                            content: [
                                {
                                    type: 'input_text',
                                    text: 'Greet the user with "Hello there! Whats up, whats on your mind?"'
                                }
                            ]
                        }
                    };

                    console.log('Sending initial conversation item');
                    openAiWs.send(JSON.stringify(initialConversationItem));
                    openAiWs.send(JSON.stringify({ type: 'response.create' }));
                };

                // Handle OpenAI connection
                openAiWs.on('open', () => {
                    console.log('Connected to OpenAI Realtime API');
                    setTimeout(initializeSession, 100);
                });

                // Handle OpenAI messages
                openAiWs.on('message', (data) => {
                    try {
                        const response = JSON.parse(data);
                        console.log('OpenAI response:', response.type);

                        if (response.type === 'response.audio.delta' && response.delta) {
                            const audioDelta = {
                                event: 'media',
                                streamSid: streamSid,
                                media: { payload: Buffer.from(response.delta, 'base64').toString('base64') }
                            };
                            connection.send(JSON.stringify(audioDelta));

                            // First delta from a new response starts the elapsed time counter
                            if (!responseStartTimestampTwilio) {
                                responseStartTimestampTwilio = latestMediaTimestamp;
                                console.log(`Setting start timestamp for new response: ${latestMediaTimestamp}ms`);
                            }

                            if (response.item_id) {
                                lastAssistantItem = response.item_id;
                            }
                            
                            sendMark(connection, streamSid);
                        } else if (response.type === 'input_audio_buffer.speech_started') {
                            handleSpeechStartedEvent();
                        }
                    } catch (error) {
                        console.error('Error processing OpenAI message:', error);
                    }
                });

                // Handle Twilio messages
                connection.on('message', async function messageHandler(rawMessage) {
                    try {
                        const message = JSON.parse(rawMessage.toString());
                        
                        if (message.event === 'start') {
                            streamSid = message.start.streamSid;
                            console.log('Call stream started:', streamSid);
                            
                            // Reset timestamps on new stream
                            responseStartTimestampTwilio = null;
                            latestMediaTimestamp = 0;

                            // Find the most recent in-progress call
                            callRecord = await db.collection('calls').findOne(
                                { status: 'in-progress' },
                                { sort: { startTime: -1 } }
                            );
                            console.log('Found call record:', callRecord?._id);
                        } else if (message.event === 'media') {
                            latestMediaTimestamp = message.media.timestamp;
                            if (openAiWs.readyState === WebSocket.OPEN) {
                                const audioAppend = {
                                    type: 'input_audio_buffer.append',
                                    audio: message.media.payload
                                };
                                openAiWs.send(JSON.stringify(audioAppend));
                            }
                        } else if (message.event === 'mark') {
                            if (markQueue.length > 0) {
                                markQueue.shift();
                            }
                        } else if (message.event === 'stop') {
                            console.log('Call stream stopped:', streamSid);
                            
                            if (callRecord) {
                                try {
                                    await db.collection('calls').updateOne(
                                        { _id: callRecord._id },
                                        { 
                                            $set: { 
                                                status: 'completed',
                                                endTime: new Date()
                                            }
                                        }
                                    );
                                    console.log('Updated call record status to completed:', callRecord._id);
                                } catch (error) {
                                    console.error('Error updating call record:', error);
                                }
                            }
                        }
                    } catch (error) {
                        console.error('Error processing message:', error);
                    }
                });

                // Handle disconnection
                connection.on('close', async function closeHandler() {
                    console.log('Call stream disconnected');
                    if (openAiWs.readyState === WebSocket.OPEN) {
                        openAiWs.close();
                    }
                });

                openAiWs.on('close', () => {
                    console.log('Disconnected from OpenAI Realtime API');
                });

                openAiWs.on('error', (error) => {
                    console.error('Error in OpenAI WebSocket:', error);
                });

                // Handle interruption when the caller's speech starts
                const handleSpeechStartedEvent = () => {
                    if (markQueue.length > 0 && responseStartTimestampTwilio != null) {
                        const elapsedTime = latestMediaTimestamp - responseStartTimestampTwilio;
                        console.log(`Calculating elapsed time for truncation: ${latestMediaTimestamp} - ${responseStartTimestampTwilio} = ${elapsedTime}ms`);

                        if (lastAssistantItem) {
                            const truncateEvent = {
                                type: 'conversation.item.truncate',
                                item_id: lastAssistantItem,
                                content_index: 0,
                                audio_end_ms: elapsedTime
                            };
                            console.log('Sending truncation event:', JSON.stringify(truncateEvent));
                            openAiWs.send(JSON.stringify(truncateEvent));
                        }

                        connection.send(JSON.stringify({
                            event: 'clear',
                            streamSid: streamSid
                        }));

                        // Reset
                        markQueue = [];
                        lastAssistantItem = null;
                        responseStartTimestampTwilio = null;
                    }
                };

                // Send mark messages to track AI response playback
                const sendMark = (connection, streamSid) => {
                    if (streamSid) {
                        const markEvent = {
                            event: 'mark',
                            streamSid: streamSid,
                            mark: { name: 'responsePart' }
                        };
                        connection.send(JSON.stringify(markEvent));
                        markQueue.push('responsePart');
                    }
                };
            } catch (error) {
                console.error('WebSocket error:', error);
                connection.socket.close();
            }
        });
    });

    // Settings Routes
    fastify.get('/settings', {
        preHandler: fastify.authenticate
    }, async (request, reply) => {
        try {
            const user = await db.collection('users').findOne({ email: request.session.user.email });
            return reply.view('settings.ejs', { 
                title: 'Settings',
                user,
                messages: {
                    success: null,
                    error: null
                }
            });
        } catch (error) {
            console.error('Error fetching user settings:', error);
            return reply.redirect('/dashboard');
        }
    });

    fastify.post('/settings', {
        preHandler: fastify.authenticate
    }, async (request, reply) => {
        try {
            const { name, currentPassword, newPassword, confirmPassword } = request.body;
            const user = await db.collection('users').findOne({ email: request.session.user.email });

            // Update name
            const updates = { name };

            // Handle password change if requested
            if (newPassword) {
                // Verify current password
                const isValidPassword = await bcrypt.compare(currentPassword, user.password);
                if (!isValidPassword) {
                    return reply.view('settings.ejs', { 
                        title: 'Settings',
                        user,
                        messages: {
                            success: null,
                            error: 'Current password is incorrect'
                        }
                    });
                }

                // Verify password confirmation
                if (newPassword !== confirmPassword) {
                    return reply.view('settings.ejs', { 
                        title: 'Settings',
                        user,
                        messages: {
                            success: null,
                            error: 'New passwords do not match'
                        }
                    });
                }

                // Hash new password
                updates.password = await bcrypt.hash(newPassword, 10);
            }

            // Update user
            await db.collection('users').updateOne(
                { email: request.session.user.email },
                { $set: updates }
            );

            return reply.view('settings.ejs', { 
                title: 'Settings',
                user,
                messages: {
                    success: 'Settings updated successfully',
                    error: null
                }
            });

        } catch (error) {
            console.error('Error updating settings:', error);
            return reply.view('settings.ejs', { 
                title: 'Settings',
                user,
                messages: {
                    success: null,
                    error: 'Failed to update settings'
                }
            });
        }
    });

    // Authentication Routes
    fastify.get('/login', async (request, reply) => {
        if (request.session && request.session.user) {
            const redirectTo = request.query.redirect || '/dashboard';
            return reply.redirect(redirectTo);
        }
        return reply.view('login.ejs', { 
            title: 'Login',
            error: null,
            redirectTo: request.query.redirect || '/dashboard'
        });
    });

    fastify.post('/login', async (request, reply) => {
        const { email, password } = request.body;
        const redirectTo = request.body.redirectTo || '/dashboard';

        try {
            // Validate input
            if (!email || !password) {
                console.log('Missing email or password');
                return reply.view('login.ejs', { 
                    title: 'Login',
                    error: 'Please provide both email and password',
                    redirectTo
                });
            }

            // Check both collections for the user
            const user = await db.collection('users').findOne({ email }) || 
                        await db.collection('pending_users').findOne({ email });
            console.log('Found user:', user ? 'yes' : 'no');
            
            if (!user) {
                console.log('User not found');
                return reply.view('login.ejs', { 
                    title: 'Login',
                    error: 'Invalid email or password',
                    redirectTo
                });
            }

            // Verify password
            const validPassword = await bcrypt.compare(password, user.password);
            console.log('Password valid:', validPassword);

            if (!validPassword) {
                console.log('Invalid password');
                return reply.view('login.ejs', { 
                    title: 'Login',
                    error: 'Invalid email or password',
                    redirectTo
                });
            }

            // Set session data
            request.session.user = {
                email: user.email,
                verified: user.verified
            };
            console.log('Session set:', request.session);

            // Save session explicitly
            await request.session.save();
            console.log('Session saved');

            // Redirect to dashboard
            return reply.redirect(redirectTo);

        } catch (error) {
            console.error('Login error:', error);
            return reply.view('login.ejs', { 
                title: 'Login',
                error: 'An error occurred during login. Please try again.',
                redirectTo
            });
        }
    });

    fastify.get('/logout', async (request, reply) => {
        // Destroy the session
        if (request.session) {
            request.session.destroy();
        }
        return reply.redirect('/login');
    });

    fastify.get('/signup', async (request, reply) => {
        if (request.session && request.session.user) {
            return reply.redirect('/dashboard');
        }
        return reply.view('signup.ejs', { 
            title: 'Sign Up',
            error: null,
            user: null
        });
    });

    fastify.post('/signup', async (request, reply) => {
        const { email, password, confirmPassword } = request.body;

        try {
            // Validate password match
            if (password !== confirmPassword) {
                return reply.view('signup.ejs', {
                    title: 'Sign Up',
                    error: 'Passwords do not match',
                    user: null
                });
            }

            // Check if user already exists
            const existingUser = await db.collection('users').findOne({ email }) || 
                               await db.collection('pending_users').findOne({ email });
            
            if (existingUser) {
                return reply.view('signup.ejs', {
                    title: 'Sign Up',
                    error: 'Email already registered',
                    user: null
                });
            }

            // Hash password
            const hashedPassword = await bcrypt.hash(password, 10);

            // Create user in pending_users collection
            const newUser = {
                email,
                password: hashedPassword,
                verified: false,
                createdAt: new Date()
            };

            await db.collection('pending_users').insertOne(newUser);

            // Set session data
            request.session.user = {
                email: newUser.email,
                verified: newUser.verified
            };

            return reply.redirect('/dashboard');
        } catch (error) {
            request.log.error('Signup error:', error);
            return reply.view('signup.ejs', {
                title: 'Sign Up',
                error: 'An error occurred during signup',
                user: null
            });
        }
    });

    fastify.post('/register-phone', { preHandler: fastify.authenticate }, async (request, reply) => {
        const { phone, name } = request.body;
        
        try {
            // Check if phone is already registered
            const existingPhone = await db.collection('users').findOne({ phone });
            if (existingPhone) {
                const user = await db.collection('pending_users').findOne({ email: request.session.user.email }) ||
                            await db.collection('users').findOne({ email: request.session.user.email });
                return reply.view('dashboard.ejs', {
                    title: 'Dashboard',
                    email: user.email,
                    phone: user.phone,
                    name: user.name,
                    verified: user.verified,
                    error: 'This phone number is already registered',
                    success: null,
                    user: user
                });
            }

            // Send verification code
            await twilioClient.verify.v2.services(TWILIO_VERIFY_SERVICE_SID)
                .verifications.create({ to: phone, channel: 'sms' });

            // Update user's phone number and name in pending_users
            await db.collection('pending_users').updateOne(
                { email: request.session.user.email },
                { $set: { phone, name, verified: false } }
            );

            const updatedUser = await db.collection('pending_users').findOne({ email: request.session.user.email });
            return reply.view('dashboard.ejs', {
                title: 'Dashboard',
                email: request.session.user.email,
                phone,
                name,
                verified: false,
                error: null,
                success: 'Verification code sent to your phone',
                user: updatedUser
            });
        } catch (error) {
            request.log.error('Phone registration error:', error);
            const user = await db.collection('pending_users').findOne({ email: request.session.user.email }) ||
                        await db.collection('users').findOne({ email: request.session.user.email });
            return reply.view('dashboard.ejs', {
                title: 'Dashboard',
                email: user.email,
                phone: user.phone,
                name: user.name,
                verified: user.verified,
                error: 'Failed to send verification code',
                success: null,
                user: user
            });
        }
    });

    fastify.post('/verify-phone', { preHandler: fastify.authenticate }, async (request, reply) => {
        const { code } = request.body;
        
        try {
            // Get user from pending_users
            const pendingUser = await db.collection('pending_users').findOne({ email: request.session.user.email });
            if (!pendingUser || !pendingUser.phone) {
                return reply.view('dashboard.ejs', {
                    title: 'Dashboard',
                    email: request.session.user.email,
                    phone: null,
                    name: null,
                    verified: false,
                    error: 'Please register your phone number first',
                    success: null,
                    user: pendingUser
                });
            }

            // Verify the code with Twilio
            const verification = await twilioClient.verify.v2
                .services(TWILIO_VERIFY_SERVICE_SID)
                .verificationChecks.create({ to: pendingUser.phone, code });

            if (verification.status === 'approved') {
                // Move user from pending_users to users collection
                const userData = { ...pendingUser, verified: true };
                delete userData._id; // Remove MongoDB _id to avoid conflicts
                
                await db.collection('users').insertOne(userData);
                await db.collection('pending_users').deleteOne({ email: request.session.user.email });

                // Update session with new verified status
                request.session.user = {
                    email: userData.email,
                    verified: true
                };

                return reply.view('dashboard.ejs', {
                    title: 'Dashboard',
                    email: userData.email,
                    phone: userData.phone,
                    name: userData.name,
                    verified: true,
                    error: null,
                    success: 'Phone number verified successfully!',
                    user: userData
                });
            } else {
                return reply.view('dashboard.ejs', {
                    title: 'Dashboard',
                    email: pendingUser.email,
                    phone: pendingUser.phone,
                    name: pendingUser.name,
                    verified: false,
                    error: 'Invalid verification code',
                    success: null,
                    user: pendingUser
                });
            }
        } catch (error) {
            console.error('Verification error:', error);
            const user = await db.collection('pending_users').findOne({ email: request.session.user.email });
            return reply.view('dashboard.ejs', {
                title: 'Dashboard',
                email: user.email,
                phone: user.phone,
                name: user.name,
                verified: false,
                error: 'Failed to verify phone number',
                success: null,
                user: user
            });
        }
    });

    // Call History Route
    fastify.get('/call-history', { preHandler: fastify.authenticate }, async (request, reply) => {
        try {
            const calls = await db.collection('calls').find({ 
                userId: request.session.user.email 
            }).sort({ startTime: -1 }).toArray();

            return reply.view('call-history.ejs', {
                title: 'Call History',
                calls,
                error: null,
                user: request.user
            });
        } catch (error) {
            request.log.error('Call history error:', error);
            return reply.view('call-history.ejs', {
                title: 'Call History',
                calls: [],
                error: 'Failed to load call history',
                user: request.user
            });
        }
    });

    // Root Route
    fastify.get('/', async (request, reply) => {
        try {
            return reply.view('index.ejs', { 
                title: 'Welcome',
                user: request.user
            });
        } catch (error) {
            request.log.error('Landing page error:', error);
            reply.code(500).send({ error: 'Internal Server Error' });
        }
    });

    // Route for Twilio to handle incoming calls
    fastify.all('/incoming-call', async (request, reply) => {
        const from = request.body?.From || request.query?.From;
        
        try {
            // Check if the phone number is registered and verified
            const user = await db.collection('users').findOne({ phone: from });
            if (!user) {
                const twimlResponse = `<?xml version="1.0" encoding="UTF-8"?>
                                <Response>
                                    <Say>Sorry, this phone number is not authorized. Please register first.</Say>
                                    <Hangup /></Response>`;
                return reply.type('text/xml').send(twimlResponse);
            }

            // Create a new call record
            const callRecord = {
                userEmail: user.email,
                phone: from,
                startTime: new Date(),
                status: 'in-progress'
            };
            const result = await db.collection('calls').insertOne(callRecord);

            // Set up TwiML response with Stream for disconnect detection
            const twimlResponse = `<?xml version="1.0" encoding="UTF-8"?>
                                <Response>
                                    <Say>Welcome back, ${user.name}! You can start chatting with your AI companion now.</Say>
                                    <Pause length="1"/>
                                    <Connect>
                                        <Stream url="wss://${request.headers.host}/call-stream" />
                                    </Connect>
                                </Response>`;
            reply.type('text/xml').send(twimlResponse);

        } catch (error) {
            console.error('Error in incoming-call:', error);
            const twimlResponse = `<?xml version="1.0" encoding="UTF-8"?>
                                <Response>
                                    <Say>Sorry, an error occurred. Please try again later.</Say>
                                    <Hangup /></Response>`;
            reply.type('text/xml').send(twimlResponse);
        }
    });

    // Webhook for call status updates
    fastify.all('/call-status', async (request, reply) => {
        const callSid = request.body?.CallSid || request.query?.CallSid;
        const callStatus = request.body?.CallStatus || request.query?.CallStatus;
        const from = request.body?.From || request.query?.From;

        console.log('Call status update received:', { callSid, callStatus, from });

        try {
            if (callStatus === 'completed' || callStatus === 'failed') {
                // Find and update the most recent in-progress call for this number
                const result = await db.collection('calls').updateOne(
                    { 
                        phone: from,
                        status: 'in-progress'
                    },
                    { 
                        $set: { 
                            status: callStatus,
                            endTime: new Date(),
                            callSid: callSid
                        }
                    }
                );
                console.log(`Updated call status to ${callStatus} for ${from}`);
            }
            reply.send({ success: true });
        } catch (error) {
            console.error('Error in call-status webhook:', error);
            reply.code(500).send({ error: 'Failed to update call status' });
        }
    });
});

// Register static files
fastify.register(import('@fastify/static'), {
    root: path.join(__dirname, 'public'),
    prefix: '/public/'
});

// Authentication middleware
fastify.decorate('authenticate', async (request, reply) => {
    try {
        if (!request.session || !request.session.user) {
            return reply.redirect('/login');
        }
    } catch (err) {
        request.log.error('Authentication error:', err);
        return reply.redirect('/login');
    }
});

// Middleware to check user state for all routes
fastify.addHook('preHandler', async (request, reply) => {
    try {
        if (request.session && request.session.user) {
            const user = await db.collection('users').findOne({ email: request.session.user.email }) ||
                        await db.collection('pending_users').findOne({ email: request.session.user.email });
            request.user = user;
        }
    } catch (error) {
        request.log.error('Error in auth hook:', error);
    }
});

// Constants
const SYSTEM_MESSAGE = 'You are a helpful and bubbly AI assistant who loves to chat about anything the user is interested about and is prepared to offer them facts. Always stay positive, but work in a joke when appropriate and be as engaging as possible.';
const VOICE = 'alloy';
const PORT = process.env.PORT || 5050;
const SHOW_TIMING_MATH = false;
const LOG_EVENT_TYPES = ['error', 'warning'];

// Start the server
const start = async () => {
    try {
        await fastify.listen({ port: PORT });
        fastify.log.info(`Server is running on port ${PORT}`);
    } catch (err) {
        fastify.log.error(err);
        process.exit(1);
    }
};

// Connect to MongoDB and start server
try {
    await connectDB();
    await start();
} catch (err) {
    console.error('Failed to start server:', err);
    process.exit(1);
}
